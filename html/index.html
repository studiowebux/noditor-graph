<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>Noditor - Graph View</title>
        <style>
            html,
            body {
                margin: 0;
                padding: 0;
                overflow: hidden;
                font-family: sans-serif;
            }

            svg {
                width: 100vw;
                height: 100vh;
                display: block;
                background-color: #fafafa;
            }

            .tooltip {
                position: absolute;
                pointer-events: none;
                padding: 4px 8px;
                background: rgba(0, 0, 0, 0.75);
                color: white;
                border-radius: 4px;
                font-size: 12px;
                display: none;
            }
        </style>
    </head>

    <body>
        <input
            type="text"
            id="searchInput"
            placeholder="Search..."
            style="
                position: fixed;
                top: 10px;
                left: 10px;
                z-index: 999;
                padding: 5px;
            "
        />
        <button
            id="relayout"
            style="position: fixed; top: 40px; left: 10px; z-index: 1000"
        >
            Force Layout
        </button>

        <svg></svg>

        <div class="tooltip" id="tooltip"></div>

        <script src="https://d3js.org/d3.v7.min.js"></script>
        <script src="./generated/items.js"></script>
        <script type="module">
            function cleanSlashes(str) {
                // Count number of slashes
                const slashCount = (str.match(/\//g) || []).length;

                if (slashCount === 1) {
                    // Remove the only slash
                    return str.replace(/\//g, "");
                } else {
                    // Replace double slashes with a single slash
                    return str.replace(/\/{2,}/g, "/").replace(/\/$/g, "");
                }
            }

            function layoutUnconnectedNodes() {
                const connectedNodeIds = new Set();

                graph.links.forEach((l) => {
                    connectedNodeIds.add(
                        typeof l.source === "object" ? l.source.id : l.source,
                    );
                    connectedNodeIds.add(
                        typeof l.target === "object" ? l.target.id : l.target,
                    );
                });

                const unconnectedNodes = graph.nodes.filter(
                    (n) => !connectedNodeIds.has(n.id),
                );

                // Layout unconnected nodes as a vertical list at the right
                const startX = -1500;
                const startY = 0;
                const spacingY = 150;

                unconnectedNodes.forEach((node, index) => {
                    node.fx = startX;
                    node.fy = startY + index * spacingY;
                });
            }

            const svg = d3.select("svg");
            const width = window.innerWidth;
            const height = window.innerHeight;
            const padding = 50;
            const boxWidth = 500;
            const boxHeight = 400;

            const tooltip = d3.select("#tooltip");
            const container = svg.append("g");

            const zoom = d3
                .zoom()
                .scaleExtent([0.1, 3])
                .on("zoom", (event) => {
                    container.attr("transform", event.transform);
                });
            svg.call(zoom);

            const simulation = d3
                .forceSimulation(graph.nodes)
                .force(
                    "link",
                    d3
                        .forceLink(graph.links)
                        .id((d) => d.id)
                        .distance(300),
                )
                .force("charge", d3.forceManyBody().strength(-300))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force(
                    "collide",
                    d3
                        .forceCollide()
                        .radius(
                            () =>
                                Math.sqrt(boxWidth ** 2 + boxHeight ** 2) / 2 +
                                padding,
                        )
                        .iterations(2), // Improve accuracy
                );

            const link = container
                .append("g")
                .attr("stroke", "#999")
                .attr("stroke-opacity", 0.6)
                .selectAll("line")
                .data(graph.links)
                .join("line")
                .attr("stroke-width", 2)
                .attr("data-source", (d) => d.source.id)
                .attr("data-target", (d) => d.target.id)
                .classed("graph-link", true);

            // START Replace the following with your data structure

            // You can create rules on whatever fields you have (d === edge)
            const edgeLabels = container
                .append("g")
                .attr("class", "edge-labels")
                .selectAll("text")
                .data(graph.links)
                .join("text")
                .attr("font-size", "2em")
                .attr("font-weight", "bold")
                .attr("fill", "#000")
                .attr("text-anchor", "middle")
                .text((d) => d.amount ?? "");

            // You can create rules on whatever fields you have (d === node)
            const node = container
                .append("g")
                .attr("class", "nodes")
                .selectAll("foreignObject")
                .data(graph.nodes)
                .join("foreignObject")
                .attr("width", boxWidth)
                .attr("height", boxHeight)
                .append("xhtml:div")
                .style("border", "1px solid #ccc")
                .style("border-radius", "8px")
                .style("padding", "6px")
                .style("background-color", (d) => {
                    switch (d.type) {
                        case "item":
                            return "#e6f2ff";
                        case "slot":
                            return "#fff0e6";
                        case "attribute":
                            return "#ffe6e6";
                        case "set":
                            return "#e6ffe6";
                        case "tier":
                            return "#f0e6ff";
                        default:
                            return "#f9f9f9";
                    }
                })
                .style("font-size", "12px")
                .style("box-shadow", "0 2px 4px rgba(0,0,0,0.1)")
                .html(
                    (d) => `
        <div><strong>${d.name}</strong></div>
        <div style="margin-top: 4px;">${d.description || "No description provided"}</div>
        <div style="margin-top: 4px;">${d.value !== undefined ? "Value: " + d.value : ""}</div>
        <div style="margin-top: 4px;">${d.weight !== undefined ? "Weight: " + d.weight : ""}</div>
        <div style="margin-top: 4px; font-size: 11px; color: #555;">Type: ${d.type}</div>
      `,
                );

            // END

            // Add drag support
            const drag = d3
                .drag()
                .on("start", (event, d) => {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    d.fx = d.x;
                    d.fy = d.y;
                })
                .on("drag", (event, d) => {
                    d.fx = event.x;
                    d.fy = event.y;
                })
                .on("end", (event, d) => {
                    if (!event.active) simulation.alphaTarget(0);
                    d.fx = null;
                    d.fy = null;
                });

            container.selectAll("foreignObject").call(drag);
            container.selectAll("foreignObject").on("click", (event, d) => {
                const connectedNodeIds = new Set();

                // Identify connected links
                link.attr("visibility", (l) => {
                    const isConnected =
                        l.source.id === d.id || l.target.id === d.id;
                    if (isConnected) {
                        connectedNodeIds.add(l.source.id);
                        connectedNodeIds.add(l.target.id);
                    }
                    return isConnected ? "visible" : "hidden";
                });

                // Hide/show nodes
                container
                    .selectAll("foreignObject")
                    .attr("visibility", (n) =>
                        connectedNodeIds.has(n.id) ? "visible" : "hidden",
                    );

                // Optional: Hide/show edge labels
                edgeLabels.attr("visibility", (l) =>
                    l.source.id === d.id || l.target.id === d.id
                        ? "visible"
                        : "hidden",
                );

                const connected = graph.links
                    .filter((l) => l.source.id === d.id || l.target.id === d.id)
                    .map((l) => (l.source.id === d.id ? l.target : l.source));

                applyStarLayout(d, connected);
            });

            svg.on("click", (event) => {
                const isClickOnSVG = event.target.tagName === "svg";
                if (isClickOnSVG) {
                    link.attr("stroke", "#999").attr("stroke-width", 2);

                    link.attr("visibility", "visible");
                    container
                        .selectAll("foreignObject")
                        .attr("visibility", "visible");
                    edgeLabels.attr("visibility", "visible");

                    const lower = document
                        .getElementById("searchInput")
                        .value.toLowerCase();
                    if (lower === "") {
                        // Reset view
                        graph.nodes.forEach((d) => {
                            d.fx = null;
                            d.fy = null;
                        });

                        layoutUnconnectedNodes();
                        simulation.alpha(1).restart();
                    }
                }
            });

            simulation.on("tick", () => {
                link.attr("x1", (d) => d.source.x)
                    .attr("y1", (d) => d.source.y)
                    .attr("x2", (d) => d.target.x)
                    .attr("y2", (d) => d.target.y);

                container
                    .selectAll("foreignObject")
                    .attr("x", (d) => d.x - 75)
                    .attr("y", (d) => d.y - 40);

                edgeLabels
                    .attr("x", (d) => (d.source.x + d.target.x) / 2)
                    .attr("y", (d) => (d.source.y + d.target.y) / 2);
            });

            function debounce(func, delay) {
                let timeout;
                return function (...args) {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(this, args), delay);
                };
            }

            const centerX = width / 2;
            const centerY = height / 2;
            const radius = 300;

            const applyStarLayout = (centerNode, connectedNodes) => {
                // Set center node
                centerNode.fx = centerX;
                centerNode.fy = centerY;

                const angleStep = (2 * Math.PI) / connectedNodes.length;
                connectedNodes.forEach((node, i) => {
                    node.fx =
                        centerX +
                        (200 * Math.max(5, connectedNodes.length - 5) +
                            padding * 2) *
                            Math.cos(i * angleStep);
                    node.fy =
                        centerY +
                        (200 * Math.max(5, connectedNodes.length - 5) +
                            padding * 2) *
                            Math.sin(i * angleStep);
                });

                layoutUnconnectedNodes();
                simulation.alpha(1).restart();
            };

            const search = debounce((query) => {
                const lower = query.toLowerCase();

                if (lower === "") {
                    // Reset view
                    graph.nodes.forEach((d) => {
                        d.fx = null;
                        d.fy = null;
                    });

                    container
                        .selectAll("foreignObject")
                        .style("display", "block");
                    container.selectAll("line").style("display", "block");
                    container
                        .selectAll(".edge-labels text")
                        .style("display", "block");

                    layoutUnconnectedNodes();
                    simulation.alpha(1).restart();
                    return;
                }

                const matchedNodeIds = graph.nodes
                    .filter((n) => n.name.toLowerCase().includes(query))
                    .map((n) => n.id);

                if (matchedNodeIds.length === 1) {
                    const matched = graph.nodes.find((n) =>
                        n.name.toLowerCase().includes(lower),
                    );
                    if (!matched) return;

                    const visibleLinks = graph.links.filter(
                        (l) =>
                            l.source.id === matched.id ||
                            l.target.id === matched.id,
                    );
                    const connectedIds = new Set();
                    visibleLinks.forEach((l) => {
                        connectedIds.add(
                            typeof l.source === "object"
                                ? l.source.id
                                : l.source,
                        );
                        connectedIds.add(
                            typeof l.target === "object"
                                ? l.target.id
                                : l.target,
                        );
                    });

                    // Apply star layout
                    const connectedNodes = graph.nodes.filter(
                        (n) => n.id !== matched.id && connectedIds.has(n.id),
                    );
                    applyStarLayout(matched, connectedNodes);

                    // Update visibility
                    container
                        .selectAll("foreignObject")
                        .style("display", (d) =>
                            connectedIds.has(d.id) ? "block" : "none",
                        );
                    container
                        .selectAll("line")
                        .style("display", (d) =>
                            connectedIds.has(d.source.id || d.source) &&
                            connectedIds.has(d.target.id || d.target)
                                ? "block"
                                : "none",
                        );
                    container
                        .selectAll(".edge-labels text")
                        .style("display", (d) =>
                            connectedIds.has(d.source.id || d.source) &&
                            connectedIds.has(d.target.id || d.target)
                                ? "block"
                                : "none",
                        );
                } else {
                    const connectedNodeIds = new Set();
                    const visibleLinks = graph.links.filter((link) => {
                        const sourceMatch = matchedNodeIds.includes(
                            link.source.id || link.source,
                        );
                        const targetMatch = matchedNodeIds.includes(
                            link.target.id || link.target,
                        );
                        if (sourceMatch || targetMatch) {
                            connectedNodeIds.add(link.source.id || link.source);
                            connectedNodeIds.add(link.target.id || link.target);
                            return true;
                        }
                        return false;
                    });

                    container
                        .selectAll("foreignObject")
                        .style("display", (d) =>
                            connectedNodeIds.has(d.id) ? "block" : "none",
                        );

                    container
                        .selectAll("line")
                        .style("display", (d) =>
                            visibleLinks.includes(d) ? "block" : "none",
                        );

                    container
                        .selectAll(".edge-labels text")
                        .style("display", (d) =>
                            visibleLinks.includes(d) ? "block" : "none",
                        );
                }
            }, 250);

            document
                .getElementById("searchInput")
                .addEventListener("input", (e) => {
                    search(e.target.value);
                });

            document
                .getElementById("relayout")
                .addEventListener("click", () => {
                    layoutUnconnectedNodes();

                    const lower = document
                        .getElementById("searchInput")
                        .value.toLowerCase();
                    if (lower === "") return;

                    const matched = graph.nodes.find((n) =>
                        n.name.toLowerCase().includes(lower),
                    );
                    if (!matched) return;

                    const visibleLinks = graph.links.filter(
                        (l) =>
                            l.source.id === matched.id ||
                            l.target.id === matched.id,
                    );
                    const connectedIds = new Set();
                    visibleLinks.forEach((l) => {
                        connectedIds.add(
                            typeof l.source === "object"
                                ? l.source.id
                                : l.source,
                        );
                        connectedIds.add(
                            typeof l.target === "object"
                                ? l.target.id
                                : l.target,
                        );
                    });

                    // Apply star layout
                    const connectedNodes = graph.nodes.filter(
                        (n) => n.id !== matched.id && connectedIds.has(n.id),
                    );
                    applyStarLayout(matched, connectedNodes);

                    // Update visibility
                    container
                        .selectAll("foreignObject")
                        .style("display", (d) =>
                            connectedIds.has(d.id) ? "block" : "none",
                        );
                    container
                        .selectAll("line")
                        .style("display", (d) =>
                            connectedIds.has(d.source.id || d.source) &&
                            connectedIds.has(d.target.id || d.target)
                                ? "block"
                                : "none",
                        );
                    container
                        .selectAll(".edge-labels text")
                        .style("display", (d) =>
                            connectedIds.has(d.source.id || d.source) &&
                            connectedIds.has(d.target.id || d.target)
                                ? "block"
                                : "none",
                        );
                });
        </script>
    </body>
</html>
